{"version":3,"sources":["main.js"],"names":["htmlElement","constructor","element","this","copy","clone","remove","append","parent","tetragon3d","speed","super","rotationSpeed","planes","children","speedMeasure","start","undefined","stop","lastMeasuredAngle","speedArr","avgSpeed","motionData","currentAngle","targetAngle","move","easing","calculateEntryValues","animateRotationY","computeAvgSpeed","console","length","applyEasing","css","Math","ceil","window","requestAnimationFrame","computeEasing","distance","speedChange","delay","startEase","slowAngles","threshold","abs","baseSpeed","steps","direction","i","push","round","parseFloat","forEach","value","computeRotatingTime","flag","rotationTime","floor","measureAngle","Date","arg","shift","$","attr","reduce","a","b","getTargetAngle","e","target","shouldChangeDirection","planeClickEvent","on","log","off","myElement","easeOutQuad","t","c","d"],"mappings":"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","file":"main.js","sourcesContent":["class htmlElement {\n  constructor(element){\n    this.element = element\n  }\n  copy(){\n    return this.element.clone()\n  }\n  remove(){\n    this.element.remove()\n  }\n  append(parent){\n      this.element.append(parent)\n  }\n}\n\nclass tetragon3d extends htmlElement{\n  constructor(element ,speed){\n    super(element);\n    this.rotationSpeed = speed > 1 ? 1 : speed;\n\n    this.planes = this.element.children('div');\n    this.speedMeasure = {\n      start: undefined,\n      stop: undefined,\n      lastMeasuredAngle: undefined,\n      speedArr: [],\n      avgSpeed: undefined\n    };\n    this.motionData = {\n      currentAngle: 0,\n      targetAngle: undefined,\n      move: true\n    };\n    this.easing = [];\n  }\n  calculateEntryValues() {\n    this.speedMeasure.avgSpeed = (30 / ( this.rotationSpeed * 60 ) );\n\n  }\n\n  animateRotationY() {\n\n    if ( !this.speedMeasure.avgSpeed ) this.calculateEntryValues();\n\n    if ( this.motionData.move ){\n\n      let rotationSpeed = this.computeRotatingTime();\n      this.computeAvgSpeed(rotationSpeed);\n\n      if (this.easing.length !== 0) {\n        console.log(this.easing);\n        this.applyEasing();\n      };\n\n      this.motionData.currentAngle -= this.rotationSpeed;\n      this.motionData.currentAngle = this.motionData.currentAngle <= -360 ? 0 : this.motionData.currentAngle;\n\n      this.element.css( \"transform\", ` translateZ(-250px) rotateY(${this.motionData.currentAngle}deg)` );\n\n      // targetAngle is set in click event, so after click event rotation will stop\n      if( Math.ceil(this.motionData.currentAngle) === this.motionData.targetAngle )\n        this.motionData.move = false;\n\n      window.requestAnimationFrame( ()=> this.animateRotationY() )\n    }\n  }\n\n\n  computeEasing(direction){\n    let distance = Math.abs( Math.abs(this.motionData.targetAngle) - Math.abs(this.motionData.currentAngle) );\n\n    let steps = distance < 20 ? 5 : 10;\n    let threshold, delay, speed, speedChange, startEase, slowAngles, easing = [];\n    let baseSpeed = this.rotationSpeed;\n\n    switch (true) {\n      case distance <= 10 :\n        delay = 0;\n        break;\n      case distance <= 20 :\n        delay = 3;\n        break;\n      case distance <= 30 :\n        delay = 8;\n        break;\n      case distance <= 40 :\n        delay = 15;\n        break;\n      case distance <= 50 :\n        delay = 24;\n        break;\n      case distance <= 60 :\n        delay = 32;\n        break;\n      case distance <= 70 :\n        delay = 40;\n        break;\n      case distance <= 80 :\n        delay = 50;\n        break;\n      case distance <= 90 :\n        delay = 60;\n        break;\n\n    }\n\n    threshold = ( distance - delay ) / steps;\n    speedChange = baseSpeed/steps;\n    speed = baseSpeed;\n    startEase = direction === \"forth\" ? this.motionData.currentAngle - delay : this.motionData.currentAngle + delay;\n    slowAngles = startEase;\n\n    threshold = direction === \"forth\" ? -threshold : threshold;\n\n\n    for(let i = 1; i < steps; i++){\n      slowAngles += threshold;\n      speed -= speedChange;\n\n      if (speed > 0) speed = speed < 0.15 ? 0.15 : speed;\n      else speed = speed > -0.15 ? -0.15 : speed;\n\n      easing[i-1] = [];\n\n      easing[i-1].push( Math.round( slowAngles ) );\n      easing[i-1].push( parseFloat( speed.toFixed(2) ) );\n    }\n    return easing;\n\n  }\n  applyEasing(){\n\n    this.easing.forEach(  value => {\n      if ( Math.round(this.motionData.currentAngle) === value[0] )\n        this.rotationSpeed = value[1];\n    })\n  }\n  computeRotatingTime(){\n\n    let currentAngle = Math.abs( Math.floor(this.motionData.currentAngle) );\n    let rotationTime;\n    let flag = !(currentAngle % 31);\n\n\n    // return if current angle haven't change from last measurement\n    if (this.speedMeasure.lastMeasuredAngle === currentAngle){\n      return null;\n    }\n\n\n    this.speedMeasure.lastMeasuredAngle = currentAngle;\n\n\n    if(this.speedMeasure.measureAngle === currentAngle){\n      this.speedMeasure.stop = new Date();\n      rotationTime =  (this.speedMeasure.stop - this.speedMeasure.start)/1000;\n      return rotationTime;\n    }\n    //every 31 degrees start time, and angle, at which speed will be measured, are set\n    if ( flag ) {\n      this.speedMeasure.measureAngle = this.motionData.currentAngle === 360 ? 30 : currentAngle + 30;\n      this.speedMeasure.start = new Date();\n    }\n    return null\n  }\n  computeAvgSpeed(arg){\n\n    if ( arg === null ) return;\n\n    this.speedMeasure.speedArr.push(arg);\n\n    if ( this.speedMeasure.speedArr.length > 4 ){\n      this.speedMeasure.speedArr.shift();\n\n    }\n    this.speedMeasure.avgSpeed = this.speedMeasure.speedArr.reduce((a,b) => a + b, 0) / this.speedMeasure.speedArr.length;\n\n  }\n\n  getTargetAngle (e) {\n\n    const targetId = $(e.target).attr(\"id\");\n\n    switch (targetId) {\n      case \"front\":\n        this.motionData.targetAngle = 0;\n        break;\n      case \"right\":\n        this.motionData.targetAngle = -90;\n        break;\n      case \"back\":\n        this.motionData.targetAngle = -180;\n        break;\n      case \"left\":\n        this.motionData.targetAngle = -270;\n        break;\n    }\n  }\n  shouldChangeDirection(){\n    let direction = \"forth\";\n    if( this.motionData.targetAngle === 0 ){\n      //if clicked in front plane, which set target angle to 0 , must have special check, cause current angle is always lesser than 0\n      this.rotationSpeed = this.motionData.currentAngle < -180 ? this.rotationSpeed : -this.rotationSpeed;\n      direction = this.motionData.currentAngle < -180 ? \"forth\" :  \"back\"\n    } else if ( this.motionData.currentAngle < this.motionData.targetAngle ){\n      //all the other cases\n      this.rotationSpeed = -this.rotationSpeed;\n      direction = \"back\"\n    }\n    return direction\n  }\n\n  planeClickEvent(flag){\n    if(flag){\n      this.planes.on( 'click', (e)=> {\n        this.getTargetAngle(e);\n\n        let direction = this.shouldChangeDirection();\n        this.easing = this.computeEasing(direction);\n        console.log(this.easing);\n\n      } )\n    } else {\n      this.planes.off()\n    }\n\n  }\n\n\n\n}\n\n$(() => {\n\n  let myElement = new tetragon3d($('#top-layer'),1);\n  myElement.animateRotationY();\n  myElement.planeClickEvent(true);\n\n  Math.easeOutQuad = function (t, b, c, d) {\n    t /= d;\n    return -c * t*(t-2) + b;\n  };\n\n  let easing = Math.easeOutQuad(0.6,54,36,0.4);\n});"]}